[{"path":"https://gitboosting.github.io/imuf/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 imuf authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/animate_imu.html","id":"section-introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"animate_imu","text":"vignette describes one may generate 3-D animation time series orientations inertial measurement unit (IMU). first follow steps described vignette(\"imuf\") generate time series orientations using walking_shin_1 dataset:","code":"library(imuf) library(purrr) # lst_ned_in <- as.list(as.data.frame(t(walking_shin_1))) %>% unname dt <- 1/50 # myCompUpdate <- function(initQ, accgyr) {   acc <- accgyr[1:3]   gyr <- accgyr[4:6]   gain <- 0.1   orientation <- compUpdate(acc, gyr, dt, initQ, gain)   orientation } # orientations <- purrr::accumulate(lst_ned_in, myCompUpdate, .init = c(1, 0, 0, 0)) # head(orientations) #> [[1]] #> [1] 1 0 0 0 #>  #> [[2]] #> [1]  0.9999657701 -0.0041990423 -0.0071175965 -0.0004080098 #>  #> [[3]] #> [1]  0.9998798598 -0.0078567189 -0.0133472834 -0.0006228269 #>  #> [[4]] #> [1]  0.9997609096 -0.0111531161 -0.0187912870 -0.0007868925 #>  #> [[5]] #> [1]  0.9996243467 -0.0139555857 -0.0235688255 -0.0009578893 #>  #> [[6]] #> [1]  0.999478521 -0.016386379 -0.027797655 -0.001209502"},{"path":"https://gitboosting.github.io/imuf/articles/animate_imu.html","id":"section-d-animation-of-imu-orientations","dir":"Articles","previous_headings":"","what":"3-D animation of IMU orientations","title":"animate_imu","text":"Next use animate_imu() function visualize 3-D animation orienations.","code":"# # time increment for animation needs to be in milli-seconds animate_imu(orientations, dt*1000)"},{"path":"https://gitboosting.github.io/imuf/articles/animate_imu.html","id":"section-d-animation-of-imu-orientations-within-shiny","dir":"Articles","previous_headings":"","what":"3-D animation of IMU orientations within Shiny","title":"animate_imu","text":"now illustrate one may display 3-D animation Shiny.","code":"if (interactive()) {   library(shiny)    ui = pageWithSidebar(     headerPanel(\"render an IMU animation example\"),     sidebarPanel(),     mainPanel(animate_imuOutput('orientations'))   )      server = function(input, output, session) {     output$orientations <- renderAnimate_imu(       animate_imu(orientations, dt*1000)     )   }      shinyApp(ui = ui, server = server) }"},{"path":"https://gitboosting.github.io/imuf/articles/imu_object.html","id":"section-introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"imu_object","text":"vignette describes way visualize shiny 3D animation inertial measurement unit (IMU) real time. setup requires: IMU connected shiny server via serial port (e.g. “COM3”) Firmware installed write IMU measurements serial port. measurement formatted six comma-separated floats: acc_x, acc_y, acc_z, gyr_x, gyr_y, gyr_z. required firmware , course, hardware dependent. assume established. core shiny logic consists three parts: Read IMU data serial port package inputs compUpdate() Call compUpdate() output quaternion represents new orientation Call imu_proxy() imu_send_data() update imu_object() widget quaternion code possible implementation shown next section explain implementation sections following .","code":""},{"path":"https://gitboosting.github.io/imuf/articles/imu_object.html","id":"section-sample-implementation","dir":"Articles","previous_headings":"","what":"Sample implementation","title":"imu_object","text":"","code":"if (interactive()) {   library(shiny)   library(serial)   library(imuf)   library(stringr)    getCon <- function(port) {     #     # set up connection for serial port     con <- serial::serialConnection(name = \"testcon\", port = port,                                     mode = \"115200,n,8,1\", newline = 1, translation = \"crlf\"     )     if (serial::isOpen(con)) close(con)     con   }      readFromSerial <- function(con) {     #     # helper - function to convert sensor coord to NED     bmi2ned <- function(bmi) {       # convert bmi coord to ned coord       c(bmi[1], -bmi[2], -bmi[3])     }     #     # helper - function to convert deg to radian     toRad <- function(deg) {       deg * pi/180     }     #     # functions to process and validate data read from serial port     isValidLength <- function(x) {       minLength <- 32       if (x <= minLength) return(FALSE)       return(TRUE)     }     str2Vec <- function(x) {       #       # data from the IMU is a row of 6 comma-separated floats:       # accx, accy, accz, gyrx, gyry, gyrz       y <- stringr::str_split_1(x, \",\") %>%         trimws() %>%         as.numeric() %>%         suppressWarnings()       y     }     isValidNumElements <- function(x) {       if (length(x) != 6) return(FALSE)       return(TRUE)     }        while (TRUE) {       nInQ <- serial::nBytesInQueue(con)[\"n_in\"]       if(!isValidLength(nInQ)) next       #       a <- serial::read.serialConnection(con) %>% str2Vec()       if(!isValidNumElements(a)) next       #       # a is the IMU output we want, exit infinite loop       break     }     # gyr from bmi270 IMU is in deg/sec, need to convert to rad/sec     list(acc = bmi2ned(a[1:3]),          gyr = bmi2ned(a[4:6]) %>% toRad())   }      runshiny <- function(port) {     #     ui = fluidPage(       actionButton(\"do\", \"Start animation\"),       imu_objectOutput(\"imu1\")     )        server = function(input, output, session) {          # initial orientation       quat0 <- c(cos(pi/4), sin(pi/4), 0, 0)          observeEvent(input$do, {         con <- getCon(port)         open(con)         quat <- quat0         while (TRUE) {           accgyr <- readFromSerial(con)           quat <- compUpdate(accgyr$acc, accgyr$gyr, dt = 1/50, initQ = quat, gain = 0.1)           imu_proxy(\"imu1\") %>%             imu_send_data(data = quat)         }       })          output$imu1 <- renderImu_object(         imu_object(quat0)       )     }     shinyApp(ui = ui, server = server)   } }"},{"path":"https://gitboosting.github.io/imuf/articles/imu_object.html","id":"section-imu-data","dir":"Articles","previous_headings":"","what":"IMU Data","title":"imu_object","text":"goal step read IMU data serial port, validate , package can used input compUpdate(). first use serial package set serial port connection. enter loop check data , whether meets certain requirements. confirm data legit, exit loop proceed package IMU measurements list two vectors: numeric vector 3 accelerometer readings another numeric vector 3 gyroscope readings. take care transform data conforms compUpdate() expects. First, transform data IMU’s coordinate system north-east-(NED) convention compUpdate() expects. Second, convert gyroscope readings deg/sec rad/sec expected compUpdate(). Whether transformations necessary depends IMU hardware firmware use.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/imu_object.html","id":"section-orientation-update","dir":"Articles","previous_headings":"","what":"Orientation update","title":"imu_object","text":"IMU readings appropriately packaged, call compUpdate() calculate new rotation quaternion represents latest orientation IMU. Besides accelerometer gyroscope readings, two inputs worth mentioning. first time duration (seconds). inverse sampling frequency (Hz) IMU. second initial orientation. quaternion output previous iteration. words, quaternion last iteration becomes initial orientation current iteration.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/imu_object.html","id":"section-animation-update","dir":"Articles","previous_headings":"","what":"Animation update","title":"imu_object","text":"last step update animation newly calculated rotation quaternion. accomplish calling imu_proxy() imu_send_data() succession. Note input imu_proxy() output id rendered imu_object().","code":""},{"path":"https://gitboosting.github.io/imuf/articles/imu_object.html","id":"section-visualization","dir":"Articles","previous_headings":"","what":"Visualization","title":"imu_object","text":"move IMU, animation shown reflect movement IMU. following example animation may look like:","code":""},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"imuf","text":"imuf package performs sensor fusion inertial measurement unit (IMU) 3-axis accelerometer 3-axis gyroscope. Specifically, compUpdate() uses complementary filtering estimate sensor’s final orientation, given initial orientation, sensor readings accelerations angular velocities time point, time duration data samples, gain factor (0 1) specifying weighting accelerometer measurements. vignette describes one may use imuf package analyze real world dataset IMU measurements.","code":"library(imuf) library(purrr) library(ggplot2)"},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"imuf","text":"walking_shin_1 dataset contains 31,946 rows sensor readings. reading consists 3 accelerations (m/s^2) 3 angular velocities (rad/sec) measurements north (x), east (y), (z) directions. data sampling rate 50 Hz, translates time duration 0.02 second readings. prepare subsequent analyses, first convert dataframe list:","code":"head(walking_shin_1) #> # A tibble: 6 × 6 #>   acc_x acc_y  acc_z   gyr_x     gyr_y   gyr_z #>   <dbl> <dbl>  <dbl>   <dbl>     <dbl>   <dbl> #> 1 -1.44 0.803 -10.0  -0.0238  0.00244  -0.0406 #> 2 -1.40 0.785  -9.94 -0.0177  0.00336  -0.0211 #> 3 -1.36 0.784  -9.95 -0.0195  0.00183  -0.0159 #> 4 -1.33 0.746  -9.97 -0.0223 -0.00275  -0.0162 #> 5 -1.32 0.724  -9.96 -0.0241 -0.000916 -0.0238 #> 6 -1.39 0.785  -9.97 -0.0186 -0.00367  -0.0312 lst_ned_in <- as.list(as.data.frame(t(walking_shin_1))) %>% unname head(lst_ned_in, 2) #> [[1]] #> [1] -1.440710900  0.803254660 -9.996989000 -0.023823744  0.002443461 #> [6] -0.040622540 #>  #> [[2]] #> [1] -1.398812300  0.785298170 -9.943120000 -0.017715093  0.003359759 #> [6] -0.021074850"},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"orientation-update","dir":"Articles","previous_headings":"","what":"Orientation update","title":"imuf","text":"now look update sensor orientation given IMU measurements. 3 steps: Create helper function Update sensor orientation one IMU reading Update sensor orientation list IMU readings","code":""},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"helper-function","dir":"Articles","previous_headings":"Orientation update","what":"Helper function","title":"imuf","text":"first wrap compUpdate() helper function:","code":"myCompUpdate <- function(initQ, accgyr) {   acc <- accgyr[1:3]   gyr <- accgyr[4:6]   dt <- 1/50   gain <- 0.1   orientation <- compUpdate(acc, gyr, dt, initQ, gain)   orientation }"},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"orientation-update-for-one-imu-reading","dir":"Articles","previous_headings":"Orientation update","what":"Orientation update for one IMU reading","title":"imuf","text":"Next, use helper function process first two sensor readings dataset. processing first reading, simply assume sensor’s initial orientation aligned world frame. However, procesing second reading, take output processing first reading initial orientation.","code":"(q1 <- myCompUpdate(c(1, 0, 0, 0), lst_ned_in[[1]])) #> [1]  0.9999657701 -0.0041990423 -0.0071175965 -0.0004080098 (q2 <- myCompUpdate(q1, lst_ned_in[[2]])) #> [1]  0.9998798598 -0.0078567189 -0.0133472834 -0.0006228269"},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"orientation-update-for-multiple-imu-readings","dir":"Articles","previous_headings":"Orientation update","what":"Orientation update for multiple IMU readings","title":"imuf","text":"Now process entire list IMU readings. take advantage purrr::accumulate() automatically takes output current iteration input next iteration: Note length output list one input list, extra element initial quaternion c(1, 0, 0, 0).","code":"orientations <- purrr::accumulate(lst_ned_in, myCompUpdate, .init = c(1, 0, 0, 0)) head(orientations, 5) #> [[1]] #> [1] 1 0 0 0 #>  #> [[2]] #> [1]  0.9999657701 -0.0041990423 -0.0071175965 -0.0004080098 #>  #> [[3]] #> [1]  0.9998798598 -0.0078567189 -0.0133472834 -0.0006228269 #>  #> [[4]] #> [1]  0.9997609096 -0.0111531161 -0.0187912870 -0.0007868925 #>  #> [[5]] #> [1]  0.9996243467 -0.0139555857 -0.0235688255 -0.0009578893"},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"application-of-orientations","dir":"Articles","previous_headings":"","what":"Application of orientations","title":"imuf","text":"result previous step list sensor orientations expressed unit 4-vector rotation quaternions. can use rotation quaternions transform vector sensor’s body frame world frame. Since walking_shin_1 dataset comes sensor strapped onto shin subject walked 10 minutes, illustration use sensor orientations study turns taken subject journey. 3 steps: Use rotV() transform vector body frame world frame Create function calculate turn angle Compute turn angles every time point","code":""},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"vector-transformation","dir":"Articles","previous_headings":"Application of orientations","what":"Vector transformation","title":"imuf","text":"can transform vector body frame world frame rotating vector orientation sensor. rotV() performs rotation. example, rotating vector pointing east-direction (c(0, 1, 0)) north-direction 90 degrees results vector pointing -direction (c(0, 0, 1)):","code":"q <- c(cos(pi/4), sin(pi/4), 0, 0) vin <- c(0, 1, 0) rotV(q, vin) #> [1] 0.000000e+00 2.220446e-16 1.000000e+00"},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"turn-angle-function","dir":"Articles","previous_headings":"Application of orientations","what":"Turn angle function","title":"imuf","text":"Next, write function compute turn angle rotated vector:","code":"getTurnAngle <- function(quat) {   # a function to rotate c(1, 0, 0) by quat   # and then compute the angle between (1, 0, 0) and the rotated vector   # projected onto the n-e plane and    # this construct is to detect turns   rotVec <- rotV(quat, c(1, 0, 0))   theta <- atan2(rotVec[2], rotVec[1]) * 180 / pi   theta }"},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"turn-angles-for-all-time-points","dir":"Articles","previous_headings":"Application of orientations","what":"Turn angles for all time points","title":"imuf","text":"Lastly, compute turn angles using purrr::map():","code":"turnAngles <- orientations %>% purrr::map(getTurnAngle) %>% unlist() head(turnAngles) #> [1]  0.00000000 -0.04333247 -0.05936656 -0.06618022 -0.07211392 -0.08646343"},{"path":"https://gitboosting.github.io/imuf/articles/imuf.html","id":"analyses-of-turn-angles","dir":"Articles","previous_headings":"Application of orientations","what":"Analyses of turn angles","title":"imuf","text":"Let’s take look results:  sharp jumps turn angles. reason atan2() restricts angles -180 +180. angle 181 becomes -179 breaking continuity. can use function remove artificial jumps maintain continuity:  remains jumps turn angles. jumps artificial. reflect actual behaviors subject journey. example, 5 minute mark, data suggests made 180 degree turn. can indeed confirmed video.","code":"# # create a vector of time stamps in minutes # note that sampling frequency is 50 Hz x <- 1:length(turnAngles) / 50 / 60 # ggplot2::ggplot(mapping = aes(x = x, y = turnAngles)) + ggplot2::geom_line() # # a function to remove artificial jumps in turn angles rmJumps <- function(theta) {   firstDiffs <- diff(theta)   bigDiffIdx <- which(abs(firstDiffs) > 100)   #   # fix #1   theta[(bigDiffIdx[1]+1):bigDiffIdx[2]] <- theta[(bigDiffIdx[1]+1):bigDiffIdx[2]] + 360   #   # fix #2   theta[(bigDiffIdx[3]+1):bigDiffIdx[4]] <- theta[(bigDiffIdx[3]+1):bigDiffIdx[4]] + 360   #   # fix #3   theta[(bigDiffIdx[4]+1):length(theta)] <- theta[(bigDiffIdx[4]+1):length(theta)] + 2*360   theta } # # remove artificial jumps turnAnglesNoJumps <- rmJumps(turnAngles) # # plot it ggplot2::ggplot(mapping = aes(x = x, y = turnAnglesNoJumps)) + ggplot2::geom_line() # # zero in on +/- 10 sec around 5 minute mark idx_5min <- c(14800:15750) x_5min <- x[idx_5min] turn_5min <- turnAnglesNoJumps[idx_5min] # # plot it ggplot2::ggplot(mapping = aes(x = x_5min, y = turn_5min)) + ggplot2::geom_line()"},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A primer on quaternions and rotations","text":"imuf package uses mathematics quaternions analyze data inertial measurement unit (IMU) track orientation 3D. use package, helpful understand quaternions operate vectors rotations.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"what-is-a-quaternion","dir":"Articles","previous_headings":"","what":"What is a quaternion?","title":"A primer on quaternions and rotations","text":"quaternion 4-componment mathematical object q=qw+iqx+jqy+kqzq = q_{w} + q_{x} + j q_{y} + k q_{z} scalar component qwq_{w} vector component (qx,qy,qz)(q_{x}, q_{y}, q_{z}). quaternion units ,j,ki, j, k analogous imaginary unit =−1i = \\sqrt{-1} complex numbers, except quaternions three units obey following relationships: i2=j2=k2=ijk=−1i^2 = j^2 = k^2 = j k = -1 ij=−ji=ki j = - j = k ki=−ik=jk = - k = j jk=−kj=ij k = - k j = Quaternion algebra similar complex number algebra, added complications four components quaternion units needing obey extensive set rules stated . ’s important note multiplication, order matters. Quaternions generally commute: q1q2≠q2q1q_{1} q_{2} \\neq q_{2} q_{1}.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"quaternions-as-rotations-and-vectors","dir":"Articles","previous_headings":"","what":"Quaternions as rotations and vectors","title":"A primer on quaternions and rotations","text":"quaternion can represent rotation vector.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"rotation-quaternions","dir":"Articles","previous_headings":"Quaternions as rotations and vectors","what":"Rotation quaternions","title":"A primer on quaternions and rotations","text":"rotation angle θ\\theta around axis 𝐯=(vx,vy,vz)\\mathbf{v} = (v_{x}, v_{y}, v_{z}) unit length vx2+vy2+vz2=1\\sqrt{v_{x}^2 + v_{y}^2 + v_{z}^2} = 1 can represented rotation quaternion: q(θ,𝐯)=cos(θ2)+sin(θ2)(ivx+jvy+kvz)q(\\theta, \\mathbf{v}) = cos(\\frac{\\theta}{2}) + sin(\\frac{\\theta}{2}) (v_{x} + j v_{y} + k v_{z}) relation quaternion components axis-angle representation : [qwqxqyqz]=[cos(θ/2)vxsin(θ/2)vysin(θ/2)vzsin(θ/2)]=[cos(θ/2)𝐯sin(θ/2)]\\begin{bmatrix} q_{w} \\\\ q_{x} \\\\ q_{y} \\\\ q_{z}  \\end{bmatrix} = \\begin{bmatrix} cos(\\theta/2) \\\\ v_{x} sin(\\theta/2) \\\\ v_{y} sin(\\theta/2) \\\\ v_{z} sin(\\theta/2) \\end{bmatrix} = \\begin{bmatrix}cos(\\theta/2) \\\\ \\mathbf{v} sin(\\theta/2)\\end{bmatrix} Rotation quaternions unit length: qw2+qx2+qy2+qz2)=1\\sqrt{q_{w}^2 + q_{x}^2 + q_{y}^2 + q_{z}^2)} = 1. numerical operation may necessary re-normalize rotation quaternion unit length.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"vector-quaternions","dir":"Articles","previous_headings":"Quaternions as rotations and vectors","what":"Vector quaternions","title":"A primer on quaternions and rotations","text":"quaternion representing vector 𝐮=(ux,uy,uz)\\mathbf{u} = (u_{x}, u_{y}, u_{z}) zero scalar part: qu=0+iux+juy+kuz=[0𝐮]q_{u} = 0 + u_{x} + j u_{y} + k u_{z} = \\begin{bmatrix} 0 \\\\ \\mathbf{u} \\end{bmatrix} Unlike rotation quaternion unit length, vector quaternion can arbitrary length.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"conjugate","dir":"Articles","previous_headings":"Quaternions as rotations and vectors","what":"Conjugate","title":"A primer on quaternions and rotations","text":"conjugate quaternion q*=qw−iqx−jqy−kqzq^* = q_{w} - q_{x} - j q_{y} - k q_{z}. Conjugate rotation quaternion represents rotation opposite direction. Conjugate vector quaternion represents vector pointing opposite direction.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"rotating-a-vector","dir":"Articles","previous_headings":"Quaternions as rotations and vectors","what":"Rotating a vector","title":"A primer on quaternions and rotations","text":"One can rotate vector, represented vector quaternion quq_{u}, rotation, represented rotation quaternion qq, using following transformation: q′u=qquq*q'_{u} = q q_{u} q^* resulting vector quaternion q′uq'_{u} represents rotated vector. example, rotating vector length 2 along y-axis x-axis 90 degrees π\\pi/2 results vector length 2 along z-axis: Another rotation z-axis leaves vector unchanged: Note rotations commute. Reversing order rotating quq_{u} z-axis π\\pi/2 first x-axis π\\pi/2 second yields different result:","code":"qu <- c(0, 0, 2, 0)   # quaternion of a vector of length 2 along the y-axis angle <- pi/2 q <- c(cos(angle/2), sin(angle/2), 0, 0)   # quaternion of a rotation about the x-axis by pi/2 qconj <- Qconj(q)    # conjugate of the rotation quaternion # qu_rotated <- q %Q*% qu %Q*% qconj qu_rotated #>      [,1] [,2]         [,3] [,4] #> [1,]    0    0 4.440892e-16    2 qu <- qu_rotated   # start with the rotated vector from previous step angle <- pi/2 q <- c(cos(angle/2), 0, 0, sin(angle/2))   # quaternion of a rotation about the z-axis by pi/2 qconj <- Qconj(q)    # conjugate of the rotation quaternion # qu_rotated <- q %Q*% qu %Q*% qconj qu_rotated #>      [,1]          [,2]         [,3] [,4] #> [1,]    0 -4.440892e-16 9.860761e-32    2 qu <- c(0, 0, 2, 0)   # start with a vector of length 2 along the y-axis angle <- pi/2 q1 <- c(cos(angle/2), 0, 0, sin(angle/2))   # rotation about the z-axis by pi/2 q2 <- c(cos(angle/2), sin(angle/2), 0, 0)   # rotation about the x-axis by pi/2 q1conj <- Qconj(q1)    # conjugate of q1 q2conj <- Qconj(q2)    # conjugate of q2 # qu_rotated <- q1 %Q*% qu %Q*% q1conj qu_rotated <- q2 %Q*% qu_rotated %Q*% q2conj # qu_rotated    # this vector quaternion is different from the one in the previous section #>      [,1] [,2]         [,3]         [,4] #> [1,]    0   -2 9.860761e-32 4.440892e-16"},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"cross-product-and-dot-product","dir":"Articles","previous_headings":"Quaternions as rotations and vectors","what":"Cross product and dot product","title":"A primer on quaternions and rotations","text":"Cross product dot product useful vector operations can performed quaternions. multiply two vector quaternions, scalar component resulting quaternion negative dot product vector component cross product: qa=0+iax+jay+kazq_{} = 0 + a_{x} + j a_{y} + k a_{z} qb=0+ibx+jby+kbzq_{b} = 0 + b_{x} + j b_{y} + k b_{z} qaqb=qc=cw+icx+jcy+kczq_{} q_{b} = q_{c} = c_{w} + c_{x} + j c_{y} + k c_{z} cw=−(ax,ay,az)⋅(bx,,bz)c_{w} = - (a_{x}, a_{y}, a_{z}) \\cdot (b_{x}, b_{y}, b_{z}) (cx,cy,cz)=(ax,ay,az)×(bx,,bz)(c_{x}, c_{y}, c_{z}) = (a_{x}, a_{y}, a_{z}) \\times (b_{x}, b_{y}, b_{z}) succinctly, qaqb=[−𝐚⋅𝐛𝐚×𝐛]q_{} q_{b} = \\begin{bmatrix} -\\mathbf{} \\cdot \\mathbf{b} \\\\ \\mathbf{} \\times \\mathbf{b} \\end{bmatrix} Let’s quickly verify concrete example:","code":"qa <- c(0, 1, 2, 3)   # some arbitrary vector qb <- c(0, 4, 5, 6)   # another arbitrary vector # (qc <- qa %Q*% qb)      # quaternion product #>      [,1] [,2] [,3] [,4] #> [1,]  -32   -3    6   -3 # # dot and cross product the normal way (a_dot_b <- qa[2:4] %*% qb[2:4]) #>      [,1] #> [1,]   32 # (a_cross_b <- cross(qa[2:4], qb[2:4])) #> [1] -3  6 -3 # # scalar of quaternion == negative dot product # vector of quaternion == cross product qc[1] == -1* a_dot_b #>      [,1] #> [1,] TRUE qc[2:4] == a_cross_b #> [1] TRUE TRUE TRUE"},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"more-quaternion-operations","dir":"Articles","previous_headings":"","what":"More quaternion operations","title":"A primer on quaternions and rotations","text":"Now familiar basic characteristics quaternions relations 3-vectors 3D rotations, let’s delve quaternion operations relevant sensor fusion.","code":""},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"finding-a-rotation-that-rotates-a-unit-vector-into-another","dir":"Articles","previous_headings":"More quaternion operations","what":"Finding a rotation that rotates a unit vector into another","title":"A primer on quaternions and rotations","text":"Say want rotate unit vector 𝐚=(ax,ay,az)\\mathbf{} = (a_{x}, a_{y}, a_{z}) another unit vector 𝐛=(bx,,bz)\\mathbf{b} = (b_{x}, b_{y}, b_{z}). Represented quaternions, vectors 𝐚\\mathbf{} 𝐛\\mathbf{b} become qa=(0,ax,ay,az)q_{} = (0, a_{x}, a_{y}, a_{z}) qb=(0,bx,,bz)q_{b} = (0, b_{x}, b_{y}, b_{z}). objective find rotation quaternion qq qb=qqaq*q_{b} = q q_{} q^*. rotation seek axis rotation 𝐧\\mathbf{n} perpendicular 𝐚\\mathbf{} 𝐛\\mathbf{b}, angle rotation θ\\theta angle 𝐚\\mathbf{} 𝐛\\mathbf{b}. 𝐧\\mathbf{n} given cross product 𝐚\\mathbf{} 𝐛\\mathbf{b}, θ\\theta can derived dot product 𝐚\\mathbf{} 𝐛\\mathbf{b}. can read qaqb=(−𝐚⋅𝐛,𝐚×𝐛)q_{} q_{b} = (- \\mathbf{} \\cdot \\mathbf{b}, \\mathbf{} \\times \\mathbf{b}). angle rotation θ\\theta cos−1(𝐚⋅𝐛)cos^{-1}(\\mathbf{} \\cdot \\mathbf{b}). Let’s verify concrete example:","code":"a <- c(1, 2, 3); (a <- a / Norm(a)) #> [1] 0.2672612 0.5345225 0.8017837 b <- c(4, 5, 7); (b <- b / Norm(b)) #> [1] 0.4216370 0.5270463 0.7378648 (qa <- c(0, a)) #> [1] 0.0000000 0.2672612 0.5345225 0.8017837 (qb <- c(0, b)) #> [1] 0.0000000 0.4216370 0.5270463 0.7378648 # (qaqb <- qa %Q*% qb) #>            [,1]        [,2]     [,3]        [,4] #> [1,] -0.9860133 -0.02817181 0.140859 -0.08451543 (a_dot_b <- -1 * qaqb[1]) #> [1] 0.9860133 (a_cross_b <- qaqb[2:4]) #> [1] -0.02817181  0.14085904 -0.08451543 # (n <- a_cross_b / Norm(a_cross_b)) #> [1] -0.1690309  0.8451543 -0.5070926 (theta <- acos(a_dot_b)) #> [1] 0.1674481 (half_theta <- theta/2) #> [1] 0.08372404 # # rotation quaternion (q <- c(cos(half_theta), sin(half_theta) * n)) #> [1]  0.99649719 -0.01413542  0.07067709 -0.04240625 # # verification (qb_expected <- q %Q*% qa %Q*% Qconj(q)) #>      [,1]     [,2]      [,3]      [,4] #> [1,]    0 0.421637 0.5270463 0.7378648 round(qb, 8) == round(qb_expected, 8) #>      [,1] [,2] [,3] [,4] #> [1,] TRUE TRUE TRUE TRUE"},{"path":"https://gitboosting.github.io/imuf/articles/quaternion_primer.html","id":"angular-distance-between-2-orientations","dir":"Articles","previous_headings":"More quaternion operations","what":"Angular distance between 2 orientations","title":"A primer on quaternions and rotations","text":"Given two orientations quantify close ? Suppose two orientations represented rotation quaternions qaq_{} qbq_{b}. can apply third quaternion qcq_{c} qaq_{} qcqa=qbq_{c} q_{} = q_{b}. qcq_{c} extra bit rotation required align qaq_{} qbq_{b}. qc=qbqa*q_{c} = q_{b} q_{}^* rotation angle qcq_{c} “angular distance” qaq_{} qbq_{b}. quantifies closeness two orientations. angle twice arccosine scalar componment qcq_{c}. θc=2×acos(qc[1])\\theta_{c} = 2 \\times acos(q_{c}[1]) Let’s look concrete example:","code":"# some arbitrary orientations (qa <- c(cosd(25), sind(25) * c(1, 1, 1)/Norm(c(1, 1, 1)))) #> [1] 0.9063078 0.2439988 0.2439988 0.2439988 (qb <- c(cosd(35), sind(35) * c(-1, -2, 3)/Norm(c(-1, -2, 3)))) #> [1]  0.8191520 -0.1532948 -0.3065895  0.4598843 # # quaternion needed to align qa and qb (qc <- qb %Q*% Qconj(qa)) #>           [,1]       [,2]       [,3]      [,4] #> [1,] 0.7424039 -0.1517857 -0.6273515 0.1795209 # # rotation angle of qc (qc_angle <- 2 * acos(qc[1])) #> [1] 1.46829 # # verify with the library function RSpincalc::QangularDifference q1 <- qa %Q*% Qone() q2 <- qb %Q*% Qone() (qc_expected <- 2 * QangularDifference(q1, q2)) #> [1] 1.46829 # (round(qc_angle, 8) == round(qc_expected, 8)) #> [1] TRUE"},{"path":"https://gitboosting.github.io/imuf/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Felix Chan. Author, maintainer, copyright holder. Ricardo Cabello. Copyright holder.           'three.js' JavaScript library","code":""},{"path":"https://gitboosting.github.io/imuf/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chan F (2025). imuf: Estimate Orientation Inertial Measurement Unit. R package version 0.6.0.9000, https://gitboosting.github.io/imuf/, https://github.com/gitboosting/imuf.","code":"@Manual{,   title = {imuf: Estimate Orientation of an Inertial Measurement Unit},   author = {Felix Chan},   year = {2025},   note = {R package version 0.6.0.9000, https://gitboosting.github.io/imuf/},   url = {https://github.com/gitboosting/imuf}, }"},{"path":"https://gitboosting.github.io/imuf/index.html","id":"imuf-","dir":"","previous_headings":"","what":"Estimate Orientation of an Inertial Measurement Unit","title":"Estimate Orientation of an Inertial Measurement Unit","text":"‘imuf’ uses complementary filtering estimate orientation inertial measurement unit (IMU) 3-axis accelerometer 3-axis gyroscope. takes IMU’s accelerometer gyroscope readings, time duration, initial orientation, ‘gain’ factor inputs, provides estimate final orientation outputs. ‘imuf’ adopts north-east-(NED) coordinate system. initial final orientations expressed quaternions (w, x, y, z) convention.","code":""},{"path":"https://gitboosting.github.io/imuf/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Estimate Orientation of an Inertial Measurement Unit","text":"can install development version imuf GitHub :","code":"install.packages(\"imuf\") # install.packages(\"pak\") pak::pak(\"gitboosting/imuf\")"},{"path":"https://gitboosting.github.io/imuf/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Estimate Orientation of an Inertial Measurement Unit","text":"basic example shows solve common problem:","code":"library(imuf) # acc <- c(0, 0, -1)         # accelerometer NED readings in g (~ 9.81 m/s^2)  gyr <- c(1, 0, 0)          # gyroscope NED readings in radians per second deltat <- 0.1              # time duration in seconds initq <- c(1, 0, 0, 0)     # initial orientation expressed as a quaternion gain <- 0.1                # a weight (0-1) given to the accelerometer readings # # final orientation expressed as a quaternion (final <- compUpdate(acc, gyr, deltat, initq, gain)) #> [1] 0.99898767 0.04498481 0.00000000 0.00000000 # # # rotate a vector pointing east by 90 deg about north q <- c(cos(pi/4), sin(pi/4), 0, 0)   # quaternion to rotate 90 deg about north vin <- c(0, 1, 0)                    # vector in east direction (vout <- rotV(q, vin))               # after rotation, vector is in down direction #> [1] 0.000000e+00 2.220446e-16 1.000000e+00"},{"path":"https://gitboosting.github.io/imuf/reference/animate_imu-shiny.html","id":null,"dir":"Reference","previous_headings":"","what":"Shiny bindings for animate_imu — animate_imu-shiny","title":"Shiny bindings for animate_imu — animate_imu-shiny","text":"Output render functions using animate_imu within Shiny applications interactive Rmd documents.","code":""},{"path":"https://gitboosting.github.io/imuf/reference/animate_imu-shiny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shiny bindings for animate_imu — animate_imu-shiny","text":"","code":"animate_imuOutput(outputId, width = \"100%\", height = \"400px\")  renderAnimate_imu(expr, env = parent.frame(), quoted = FALSE)"},{"path":"https://gitboosting.github.io/imuf/reference/animate_imu-shiny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shiny bindings for animate_imu — animate_imu-shiny","text":"outputId output variable read width, height Must valid CSS unit (like '100%', '400px', 'auto') number, coerced string 'px' appended. expr expression generates animate_imu env environment evaluate expr. quoted expr quoted expression (quote())? useful want save expression variable.","code":""},{"path":"https://gitboosting.github.io/imuf/reference/animate_imu.html","id":null,"dir":"Reference","previous_headings":"","what":"Animate movement of an inertial measurement unit — animate_imu","title":"Animate movement of an inertial measurement unit — animate_imu","text":"Create interactive animated movements inertial measurement unit","code":""},{"path":"https://gitboosting.github.io/imuf/reference/animate_imu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Animate movement of an inertial measurement unit — animate_imu","text":"","code":"animate_imu(data, dt, width = NULL, height = NULL, elementId = NULL)"},{"path":"https://gitboosting.github.io/imuf/reference/animate_imu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Animate movement of an inertial measurement unit — animate_imu","text":"data list numeric 4-vectors unit quaternion (w,x,y,z) dt numeric time duration milli-seconds width, height width height animate_imu htmlwidget specified valid CSS size unit elementId string id valid CSS element id.","code":""},{"path":"https://gitboosting.github.io/imuf/reference/compUpdate.html","id":null,"dir":"Reference","previous_headings":"","what":"Update orientation with 3-axis acc and gyr data — compUpdate","title":"Update orientation with 3-axis acc and gyr data — compUpdate","text":"compUpdate() uses complementary filtering update orientation, given initial orientation, readings 3-axis accelerometer 3-axis gyroscope. time duration, gain factor","code":""},{"path":"https://gitboosting.github.io/imuf/reference/compUpdate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update orientation with 3-axis acc and gyr data — compUpdate","text":"","code":"compUpdate(acc, gyr, dt, initQuat, gain)"},{"path":"https://gitboosting.github.io/imuf/reference/compUpdate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update orientation with 3-axis acc and gyr data — compUpdate","text":"acc numeric 3-vector 3-axis accelerometer readings g gyr numeric 3-vector 3-axis gyroscope readings rad/sec dt numeric time duration sec initQuat numeric 4-vector starting orientation quaternion gain numeric gain factor 0 1","code":""},{"path":"https://gitboosting.github.io/imuf/reference/compUpdate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update orientation with 3-axis acc and gyr data — compUpdate","text":"numeric 4-vector ending orientation quaternion","code":""},{"path":"https://gitboosting.github.io/imuf/reference/compUpdate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update orientation with 3-axis acc and gyr data — compUpdate","text":"","code":"compUpdate(c(0, 0, -1), c(1, 0, 0), 0.1, c(1, 0, 0, 0), 0.1) #> [1] 0.99898767 0.04498481 0.00000000 0.00000000"},{"path":"https://gitboosting.github.io/imuf/reference/imu_object-shiny.html","id":null,"dir":"Reference","previous_headings":"","what":"Shiny bindings for imu_object — imu_object-shiny","title":"Shiny bindings for imu_object — imu_object-shiny","text":"Output render functions using imu_object within Shiny applications interactive Rmd documents.","code":""},{"path":"https://gitboosting.github.io/imuf/reference/imu_object-shiny.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shiny bindings for imu_object — imu_object-shiny","text":"","code":"imu_objectOutput(outputId, width = \"100%\", height = \"400px\")  renderImu_object(expr, env = parent.frame(), quoted = FALSE)"},{"path":"https://gitboosting.github.io/imuf/reference/imu_object-shiny.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shiny bindings for imu_object — imu_object-shiny","text":"outputId output variable read width, height Must valid CSS unit (like '100%', '400px', 'auto') number, coerced string 'px' appended. expr expression generates imu_object env environment evaluate expr. quoted expr quoted expression (quote())? useful want save expression variable.","code":""},{"path":"https://gitboosting.github.io/imuf/reference/imu_object-update.html","id":null,"dir":"Reference","previous_headings":"","what":"Update a widget in shiny with an orientation — imu_object-update","title":"Update a widget in shiny with an orientation — imu_object-update","text":"Pair functions used conjunction update imu_object widget","code":""},{"path":"https://gitboosting.github.io/imuf/reference/imu_object-update.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update a widget in shiny with an orientation — imu_object-update","text":"","code":"imu_proxy(id, session = shiny::getDefaultReactiveDomain())  imu_send_data(proxy, data)"},{"path":"https://gitboosting.github.io/imuf/reference/imu_object-update.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update a widget in shiny with an orientation — imu_object-update","text":"id HTML element id houses html widget session shiny session - default current session proxy imu_proxy output used input imu_send_data data numeric unit 4-vector (quaternion) updated orientation","code":""},{"path":"https://gitboosting.github.io/imuf/reference/imu_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Animate in real time movement of an inertial measurement unit in shiny — imu_object","title":"Animate in real time movement of an inertial measurement unit in shiny — imu_object","text":"Create real time animated movements inertial measurement unit shiny","code":""},{"path":"https://gitboosting.github.io/imuf/reference/imu_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Animate in real time movement of an inertial measurement unit in shiny — imu_object","text":"","code":"imu_object(data = c(1, 0, 0, 0), width = NULL, height = NULL, elementId = NULL)"},{"path":"https://gitboosting.github.io/imuf/reference/imu_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Animate in real time movement of an inertial measurement unit in shiny — imu_object","text":"data vector numeric 4-vectors unit quaternion (w,x,y,z) width, height width height imu_object htmlwidget specified valid CSS size unit elementId string id valid CSS element id.","code":""},{"path":"https://gitboosting.github.io/imuf/reference/imuf-package.html","id":null,"dir":"Reference","previous_headings":"","what":"imuf: Estimate Orientation of an Inertial Measurement Unit — imuf-package","title":"imuf: Estimate Orientation of an Inertial Measurement Unit — imuf-package","text":"Estimate orientation inertial measurement unit (IMU) 3-axis accelerometer 3-axis gyroscope using complementary filter. 'imuf' takes IMU's accelerometer gyroscope readings, time duration, initial orientation, gain factor inputs, returns estimate IMU's final orientation.","code":""},{"path":[]},{"path":"https://gitboosting.github.io/imuf/reference/imuf-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"imuf: Estimate Orientation of an Inertial Measurement Unit — imuf-package","text":"Maintainer: Felix Chan chanfelix@gmail.com [copyright holder] contributors: Ricardo Cabello ('three.js' JavaScript library) [copyright holder]","code":""},{"path":"https://gitboosting.github.io/imuf/reference/rotV.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate a 3-vector by a quaternion — rotV","title":"Rotate a 3-vector by a quaternion — rotV","text":"rotV() rotates 3-vector quaternion expressed unit 4-vector (w,x,y,z) convention","code":""},{"path":"https://gitboosting.github.io/imuf/reference/rotV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate a 3-vector by a quaternion — rotV","text":"","code":"rotV(quat, vin)"},{"path":"https://gitboosting.github.io/imuf/reference/rotV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate a 3-vector by a quaternion — rotV","text":"quat numeric unit 4-vector (w,x,y,z) rotation quaternion vin numeric 3-vector rotated quat","code":""},{"path":"https://gitboosting.github.io/imuf/reference/rotV.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotate a 3-vector by a quaternion — rotV","text":"numeric 3-vector rotation","code":""},{"path":"https://gitboosting.github.io/imuf/reference/rotV.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rotate a 3-vector by a quaternion — rotV","text":"","code":"q <- c(cos(pi/4), sin(pi/4), 0, 0) vin <- c(0, 1, 0) rotV(q, vin) #> [1] 0.000000e+00 2.220446e-16 1.000000e+00"},{"path":"https://gitboosting.github.io/imuf/reference/walking_shin_1.html","id":null,"dir":"Reference","previous_headings":"","what":"University of Mannheim Real World Activities — walking_shin_1","title":"University of Mannheim Real World Activities — walking_shin_1","text":"Accelerations angular velocities captured sensors mobile device situated shin subject 1 subject walking 10 minutes","code":""},{"path":"https://gitboosting.github.io/imuf/reference/walking_shin_1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"University of Mannheim Real World Activities — walking_shin_1","text":"","code":"walking_shin_1"},{"path":[]},{"path":"https://gitboosting.github.io/imuf/reference/walking_shin_1.html","id":"walking-shin-","dir":"Reference","previous_headings":"","what":"walking_shin_1","title":"University of Mannheim Real World Activities — walking_shin_1","text":"data frame 31,946 rows 6 columns accelerometer gyroscope measurements 50 Hz acc_x, acc_y, acc_z north, east acceleration m/s^2 gyr_x, gyr_y, gyr_z angular velocity north, east rad/sec","code":""},{"path":"https://gitboosting.github.io/imuf/reference/walking_shin_1.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"University of Mannheim Real World Activities — walking_shin_1","text":"https://www.uni-mannheim.de/dws/research/projects/activity-recognition/dataset/dataset-realworld/s1/","code":""},{"path":[]},{"path":"https://gitboosting.github.io/imuf/news/index.html","id":"imuf-060","dir":"Changelog","previous_headings":"","what":"imuf 0.6.0","title":"imuf 0.6.0","text":"CRAN release: 2025-02-12","code":""},{"path":"https://gitboosting.github.io/imuf/news/index.html","id":"imuf-06","dir":"Changelog","previous_headings":"","what":"imuf 0.6","title":"imuf 0.6","text":"suite functions real time animation IMU shiny. Core functions: imu_object(), imu_objectOutput(), renderImu_object() Support functions: imu_proxy(), imu_send_data() vignette(\"imu_object\") implement real time animation IMU shiny.","code":""},{"path":"https://gitboosting.github.io/imuf/news/index.html","id":"imuf-051","dir":"Changelog","previous_headings":"","what":"imuf 0.5.1","title":"imuf 0.5.1","text":"CRAN release: 2025-01-15","code":""},{"path":"https://gitboosting.github.io/imuf/news/index.html","id":"imuf-050","dir":"Changelog","previous_headings":"","what":"imuf 0.5.0","title":"imuf 0.5.0","text":"CRAN release: 2025-01-11 Added animation IMU orientations","code":""},{"path":"https://gitboosting.github.io/imuf/news/index.html","id":"imuf-040","dir":"Changelog","previous_headings":"","what":"imuf 0.4.0","title":"imuf 0.4.0","text":"CRAN release: 2024-12-08 Added rotV()rotate 3-vector quaternion Added walking_shin_1 dataset Better function documentation Added vignette","code":""},{"path":"https://gitboosting.github.io/imuf/news/index.html","id":"imuf-030","dir":"Changelog","previous_headings":"","what":"imuf 0.3.0","title":"imuf 0.3.0","text":"CRAN release: 2024-11-06","code":""},{"path":"https://gitboosting.github.io/imuf/news/index.html","id":"imuf-021","dir":"Changelog","previous_headings":"","what":"imuf 0.2.1","title":"imuf 0.2.1","text":"CRAN release: 2024-10-17","code":""},{"path":[]},{"path":"https://gitboosting.github.io/imuf/news/index.html","id":"imuf-010","dir":"Changelog","previous_headings":"","what":"imuf 0.1.0","title":"imuf 0.1.0","text":"Initial CRAN submission.","code":""}]
